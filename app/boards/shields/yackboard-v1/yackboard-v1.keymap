// This is the key map of the Yackboard v1 with the improved OPY layout.

#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/mouse.h>   // This is required when using &mkp mouse key events.
#include <dt-bindings/zmk/bt.h>      // This is required when using &bt bluetooth commands.
#include <dt-bindings/zmk/outputs.h> // This is required when using the &out output commands.

// The following are illegal keycodes (above 0x00ff) with usage page 0x07. They are automatically
// removed by the event handler of the "zmk,behavior-antecedent-morph" as soon as one such
// behavior is defined and so cannot print anything. But they can be used as antecedents in
// that behavior and modify the subsequent key. For example, the slash can act as a dead key
// and modify the subsequent o to an Ã¸.
#define D_SLASH 0x070100
#define D_CIRQ  0x070101

// The position codes of the left, right and thumb keys:
#define POSITION_L  0  1  2  3  4  5 12 13 14 15 16 17 24 25 26 27 28 29
#define POSITION_R  6  7  8  9 10 11 18 19 20 21 22 23 30 31 32 33 34 35
#define POSITION_T 36 37 38 39 40 41 42 43 44 45

// Macros in order to generate the code for combos

#define DEF_MACRO(NAME,LABEL,BINDINGS) \
    mac_##NAME: macro_##NAME { \
      label = LABEL ; \
      compatible = "zmk,behavior-macro"; \
      #binding-cells = <0>; \
      bindings = <&macro_tap BINDINGS &kp SPACE>; \
    };

#define DEF_COMBO(NAME,BINDINGS,KEYPOS,LAYERS) \
  combo_##NAME { \
    timeout-ms = <50>; \
    bindings = <BINDINGS>; \
    key-positions = <KEYPOS>; \
    layers = <LAYERS>; \
  };

// The dedicated shift key has got the following functions:
// - If held down, it is the shift modifier. The modifier is immediately active, and so mouse buttons can be pressed together with shift (hold-while-undecided).
// - If held down, but no other key is tapped, it reverts to the default layer (note that this requires my version of th custom retro-tap patch.
// - If tapped once, it is a one-shot shift, i.e. applies shift to the subsequent key.
// - If tapped twice, it is my flavour of caps word, i.e. it capitalizes the subsequent word (including the underscore).
//
// This is implemented as follows:
// - First, there is a hold-tap with hold the LSHFT and tap the sticky key explained in the following. This hold-tap has a custom retro-tap behaviour which resets the layer to default.
// - The sticky key produces a one-shot version of a macro that applies the following two modifiers.
// - The shift modifier (for the one-shot shift) and the momentarily applied special layer L_SHF (which does nothing other than modifying the behaviour of the shift key) for the following reason:
// - Note that the sicky key has the quick-release flag so that if the following key press is a macro that taps several keys, only the first letter is capitalized.
// - On the special layer L_SHF the shift key is my flavour of caps-word - otherwise that layer is transparent. This implements the second tap behavior of the shift key.
// - The outer hold-tap has all features of urob's Timeless Homerow Mods that are explained in the subsequent block. In addition, there is hold-while-undecided and the custom retro-tap,
//   but no require-prior-idle-ms.

/ {
  macros {
    macro_shf: macro_layer_and_shift { // this macro applies the two modifiers when the shift key is tapped for the first time
      compatible = "zmk,behavior-macro";
      label = "MACRO_LAYER_AND_SHIFT";
      #binding-cells = <0>;
      wait-ms = <0>;
      tap-ms = <1>;
      bindings
      = <&macro_press   &mo L_SHF &kp LSHFT>
      , <&macro_pause_for_release>
      , <&macro_release &mo L_SHF &kp LSHFT>
      ;
    };
  };

  behaviors {
    sticky_shift: sticky_layer_and_shift { // this is the sticky behaviour of the macro when the dedicated shift key is pressed for the first time
      compatible = "zmk,behavior-sticky-key";
      label = "STICKY_LAYER_AND_SHIFT";
      #binding-cells = <1>;
      release-after-ms = <1000>;
      bindings = <&macro_shf>;
      ignore-modifiers;
      quick-release;
    };
    hold_shift: hold_tap_shift { // this is the hold-tap for the dedicated shift key
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_SHIFT";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      hold-while-undecided;
      bindings = <&kp>, <&sticky_shift>;
      retro-tap;
      retro-tap-behavior = "to_layer";
      retro-tap-param1 = <L_DEF>;
    };
    mycaps: behavior_my_caps_word { // my version of Caps Word includes the underscore as a letter.
      compatible = "zmk,behavior-caps-word";
      label = "MY_CAPS";
      #binding-cells = <0>;
      continue-list = <UNDER>;
    };
  };
};

// There are two variants of home row hold-tap modifiers: mod-tap for [Ctrl], [Alt] and [Win] and layer-tap for the keys
// that momentarily activate the number, navigation, function and dead key layers.
//
// If the tap binding is a key press, the key code is taken from the second parameter of the behavior. If the tap binding
// is another behavior, however, for example if the tap binding is an adaptive key, this must be defined as a separate
// behavior.
//
// The following ideas are from urob's Timeless Homerow Mods of https://github.com/urob/zmk-config:
//
// flavor = "balanced";
//   Tapping and releasing a second key triggers the hold behaviour even if the tapping-term-ms has not yet passed.
//
// require-prior-idle-ms = <150>;
//   The hold function can trigger only if at least this time has passed since the previous key press, i.e. when
//   typing fast, the hold function requires a tiny pause to activate. I am not using this as I need the hold function
//   on the layer change keys for numbers and navigation quicker than that.
//
// hold-trigger-key-positions = <...>;
//   All key position codes not listed here, i.e. those in the same block, require the full tapping-time-ms to
//   pass before the hold function can trigger.
//
// hold-trigger-on-release;
//   The tapping-time-ms for the hold-trigger-key-posititons is measured until the subsequent key is released,
//   i.e. it is possible to combine two modifiers on the same side of the key board and trigger a hold with
//   a third tapped key on the other side without waiting.
//
// tapping-term-ms = <200>;
//   In order to trigger a hold without pressing a second key or with pressing a key on the same side, this
//   period needs to pass.
//
// In addidion, I set a quick-tap time, and so if the key is tapped twice in rapid succession, the second key
// press is a tap even if the key is then held. This way, the key repeat function of the operating system
// can activete even on a hold-tap key.
//
// The following are all specializations of &ht.

/ {
  behaviors {
    mohtl: modifier_hold_tapl { // the home row modifiers on the left side
      compatible = "zmk,behavior-hold-tap";
      label = "MODIFIER_HOLD_TAP_L";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      quick-tap-ms = <175>;
      hold-trigger-key-positions = <POSITION_R POSITION_T>;
      hold-trigger-on-release;
      bindings = <&kp>, <&kp>;
    };
    mohtr: modifier_hold_tapr { // the home row modifiers on the right side
      compatible = "zmk,behavior-hold-tap";
      label = "MODIFIER_HOLD_TAP_R";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      quick-tap-ms = <175>;
      hold-trigger-key-positions = <POSITION_L POSITION_T>;
      hold-trigger-on-release;
      bindings = <&kp>, <&kp>;
    };
    mohta: modifier_hold_tapa { // the home row modifier for adaptive A
      compatible = "zmk,behavior-hold-tap";
      label = "MODIFIER_HOLD_TAP_A";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      quick-tap-ms = <175>;
      hold-trigger-key-positions = <POSITION_R POSITION_T>;
      hold-trigger-on-release;
      bindings = <&kp>, <&ad_a>;
    };
    mohtu: modifier_hold_tapu { // the home row modifier for adaptive U
      compatible = "zmk,behavior-hold-tap";
      label = "MODIFIER_HOLD_TAP_U";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      quick-tap-ms = <175>;
      hold-trigger-key-positions = <POSITION_R POSITION_T>;
      hold-trigger-on-release;
      bindings = <&kp>, <&ad_u>;
    };
    mohtn: modifier_hold_tapn { // the home row modifier for adaptive N
      compatible = "zmk,behavior-hold-tap";
      label = "MODIFIER_HOLD_TAP_N";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      quick-tap-ms = <175>;
      hold-trigger-key-positions = <POSITION_L POSITION_T>;
      hold-trigger-on-release;
      bindings = <&kp>, <&ad_n>;
    };
    lyhtl: layer_hold_tapl { // the home row momentary layer keys on the left side
      compatible = "zmk,behavior-hold-tap";
      label = "LAYER_HOLD_TAP_L";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      quick-tap-ms = <175>;
      hold-trigger-key-positions = <POSITION_R POSITION_T>;
      hold-trigger-on-release;
      bindings = <&mo>, <&kp>;
    };
    lyhtr: layer_hold_tapr { // the home row momentary layer keys on the right side
      compatible = "zmk,behavior-hold-tap";
      label = "LAYER_HOLD_TAP_R";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      quick-tap-ms = <175>;
      hold-trigger-key-positions = <POSITION_L POSITION_T>;
      hold-trigger-on-release;
      bindings = <&mo>, <&kp>;
    };
    lyhtq: layer_hold_tapq { // the home row layer key for adaptive Q; note that instead of a key-press, this calls the macro for Qu and only in the retro-tap case a single Q
      compatible = "zmk,behavior-hold-tap";
      label = "LAYER_HOLD_TAPQ";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      quick-tap-ms = <175>;
      hold-trigger-key-positions = <POSITION_R POSITION_T>;
      hold-trigger-on-release;
      bindings = <&mo>, <&qu_mod>;
      retro-tap;
      retro-tap-behavior = "key_press"; // this requiree the custom retro-tap patch; note that the alternative behaviour is defined using control strings such as this
      retro-tap-param1 = <Q>;
    };
    lyhth: layer_hold_taph { // the home row layer key for adaptive H
      compatible = "zmk,behavior-hold-tap";
      label = "LAYER_HOLD_TAPH";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      quick-tap-ms = <175>;
      hold-trigger-key-positions = <POSITION_R POSITION_T>;
      hold-trigger-on-release;
      bindings = <&mo>, <&ad_h>;
    };
    lyhtg: layer_hold_tapg { // the home row layer key for adaptive G
      compatible = "zmk,behavior-hold-tap";
      label = "LAYER_HOLD_TAPG";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      quick-tap-ms = <175>;
      hold-trigger-key-positions = <POSITION_L POSITION_T>;
      hold-trigger-on-release;
      bindings = <&mo>, <&ad_g>;
    };
    lyhtss: layer_hold_tapss { // the home row layer key for ss
      compatible = "zmk,behavior-hold-tap";
      label = "LAYER_HOLD_TAPSS";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      quick-tap-ms = <175>;
      hold-trigger-key-positions = <POSITION_L POSITION_T>;
      hold-trigger-on-release;
      bindings = <&mo>, <&shsz>;
    };
  };
};

// The dedicated layer cycle keys switch layers or, if held down, revert to the basic layer.

/ {
  behaviors {
    ltt: layer_to_tap { // the layer switch key on the right half is &to if tapped and &to if held down
      compatible = "zmk,behavior-hold-tap";
      label = "LAYER_TO_TAP";
      #binding-cells = <2>;
      tapping-term-ms = <200>;
      bindings = <&to>, <&to>;
    };
  };
};

// There are a few keys that use the hold-tap function in order to issue a different symbol if held longer.

/ {
  behaviors {
    ht: hold_tap_general {
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_GENERAL";
      #binding-cells = <2>;
      flavor = "balanced";
      quick-tap-ms = <175>;
      tapping-term-ms = <200>;
      bindings = <&kp>, <&kp>;
    };
  };
};

// On the backspace key, there are also functions to delete the subsequent or the previous word
// by issuing the Emacs key combinations C-DEL or M-Backspace, respectively.

/ {
  macros {
    wd_del: ctrl_delete {
      label = "C-DEL";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_press &kp LCTRL>, <&macro_tap &kp DEL>, <&macro_release &kp LCTRL>;
    };
    wd_back: alt_backspace {
      label = "M-BSPC";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_press &kp LALT>, <&macro_tap &kp BSPC>, <&macro_release &kp LALT>;
    };
  };
};

// For some keys, the shifted variant is constructed manually.
//
// The backspace key with shift gives delete. If held longer, backspace deletes the previous word
// delete deletes the subsequent word.

/ {
  behaviors {
    ht_del: hold_tap_delete {
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_DELETE";
      #binding-cells = <2>;
      flavor = "balanced";
      quick-tap-ms = <175>;
      tapping-term-ms = <200>;
      bindings = <&wd_del>, <&kp>;
    };
    ht_back: hold_tap_backspace {
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_BACKSPACE";
      #binding-cells = <2>;
      flavor = "balanced";
      quick-tap-ms = <175>;
      tapping-term-ms = <200>;
      bindings = <&wd_back>, <&kp>;
    };
    shbs: shift_backspace { // the backspace key with [Shift] is [Del]
      compatible = "zmk,behavior-mod-morph";
      label = "SHIFT_BACKSPACE";
      #binding-cells = <0>;
      bindings = <&ht_back BSPC BSPC>, <&ht_del DEL DEL>;
      mods = <(MOD_LSFT|MOD_RSFT)>;
    };
    shsz: shift_sz { // the [Ã] with [Shift] is the [Â§] sign
      compatible = "zmk,behavior-mod-morph";
      label = "SHIFT_SZ";
      #binding-cells = <0>;
      bindings = <&kp RA(S)>, <&kp RA(LS(S))>;
      mods = <(MOD_LSFT|MOD_RSFT)>;
    };
  };
};

// The diacritics on the navigation and punctuation layer are non-dead. This is implemented by sending a sequence of
// first the diacritic and then a spcace.

/ {
  macros {
    nd_grave: non_dead_grave { // non-dead version of the grave accent
      label = "NON_DEAD_GRAVE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp GRAVE &kp SPACE>;
    };
    nd_apos: non_dead_apostrophe { // non-dead version of the apostrophe (which otherwise plays the role of the acute accent)
      label = "NON_DEAD_APOSTROPHE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp APOS &kp SPACE>;
    };
    nd_dqt: non_dead_doublequote { // non-dead version of the double quote
      label = "NON_DEAD_DOUBLEQUOTE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp DQT &kp SPACE>;
    };
    nd_caret: non_dead_caret { // non-dead version of the caret
      label = "NON_DEAD_CARET";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp CARET &kp SPACE>;
    };
    nd_tilde: non_dead_tilde { // non-dead version of the tilde
      label = "NON_DEAD_TILDE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp TILDE &kp SPACE>;
    };
  };
};

// On the number layer, there are hold-tap keys that send some of these non-dead diacritics.

/ {
  behaviors {
    ht_apos: hold_tap_apostrophe { // a hold-tap that sends the non-dead apostrophe on hold.
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_APOSTROPHE";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      bindings = <&nd_apos>, <&kp>;
    };
    ht_caret: hold_tap_caret { // a hold-tap that sends the non-dead caret on hold.
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_CARET";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      bindings = <&nd_caret>, <&kp>;
    };
  };
};

// The following macros produce pairs of brackets and place the cursor in between.

/ {
  macros {
    br_par: pair_parentheses {
      label = "PAIR_PARENTHESES";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp LPAR &kp RPAR &kp LEFT>;
    };
    br_bkt: pair_brackets {
      label = "PAIR_BRACKETS";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp LBKT &kp RBKT &kp LEFT>;
    };
    br_brc: pair_braces {
      label = "PAIR_BRACES";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp LBRC &kp RBRC &kp LEFT>;
    };
    br_ang: pair_angular {
      label = "PAIR_ANGULAR";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp LS(COMMA) &kp LS(DOT) &kp LEFT>;
    };
  };
  behaviors {
    ht_par: hold_tap_parentheses {
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_PARENTHESES";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      bindings = <&br_par>, <&kp>;
    };
    ht_bkt: hold_tap_brackets {
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_BRACKETS";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      bindings = <&br_bkt>, <&kp>;
    };
    ht_brc: hold_tap_braces {
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_BRACES";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      bindings = <&br_brc>, <&kp>;
    };
    ht_ang: hold_tap_angular {
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_ANGULAR";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      bindings = <&br_ang>, <&kp>;
    };
  };
};

// Adaptive keys (fast, 250 ms) in order to avoid same finger bigrams.

/ {
  behaviors {
    ad_m: adaptive_m {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_M";
      #binding-cells = <0>;
      defaults = <&kp M>;
      bindings = <&kp L>;
      max-delay-ms = <250>;
      antecedents = <C>;
    };
    ad_h: adaptive_h {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_H";
      #binding-cells = <0>;
      defaults = <&kp H>;
      bindings = <&kp I>;
      max-delay-ms = <250>;
      antecedents = <K>;
    };
    ad_u: adaptive_u {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_U";
      #binding-cells = <0>;
      defaults = <&kp U>;
      bindings = <&kp O>;
      max-delay-ms = <250>;
      antecedents = <Y>;
    };
    ad_n: adaptive_n {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_N";
      #binding-cells = <0>;
      defaults = <&kp N>;
      bindings = <&kp U>;
      max-delay-ms = <250>;
      antecedents = <P>;
    };
    ad_x: adaptive_x {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_X";
      #binding-cells = <0>;
      defaults = <&kp X>;
      bindings = <&kp M>;
      max-delay-ms = <250>;
      antecedents = <N>;
    };
    ad_j: adaptive_j {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_J";
      #binding-cells = <0>;
      defaults = <&kp J>;
      bindings = <&kp U>;
      max-delay-ms = <250>;
      antecedents = <K>;
    };
    ad_ue: adaptive_ue {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_UE";
      #binding-cells = <0>;
      defaults = <&kp RA(Y)>;
      bindings = <&kp P>, <&kp P>;
      max-delay-ms = <250>;
      antecedents = <U P>;
    };
    ad_g: adaptive_g {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_G";
      #binding-cells = <0>;
      defaults = <&kp G>;
      bindings = <&kp L>;
      max-delay-ms = <250>;
      antecedents = <B>;
    };
  };
};

// Adaptive keys (slow, 1 sec) that implement additional dead keys.

/ {
  behaviors {
    ad_o: adaptive_o { // implements the dead slash
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_O";
      #binding-cells = <0>;
      defaults = <&kp O>;
      bindings = <&kp RA(L)>;
      max-delay-ms = <1000>;
      antecedents = <D_SLASH>;
    };
    ad_a: adaptive_a { // implements the dead circle
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_A";
      #binding-cells = <0>;
      defaults = <&kp A>;
      bindings = <&kp RA(W)>;
      max-delay-ms = <1000>;
      antecedents = <D_CIRQ>;
    };
  };
};

// Special treatment of Q

/ {
  macros {
    qu_low: qu_lowercase {
      label = "QU_LOWERCASE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp Q &kp U>;
    };
    qu_upp: qu_uppercase {
      label = "QU_UPPERCASE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp LS(Q) &kp U>;
    };
  };
  behaviors {
    qu_mod: qu_modifier {
      compatible = "zmk,behavior-mod-morph";
      label = "QU_MODIFIER";
      #binding-cells = <0>;
      bindings = <&qu_low>, <&qu_upp>;
      mods = <(MOD_LSFT|MOD_RSFT)>;
    };
  };
};

// Macros for combos

/ {
  macros {
    DEF_MACRO (the, "MAC_THE", &kp T &kp H &kp E)
    DEF_MACRO (of,  "MAC_OF",  &kp O &kp F)
    DEF_MACRO (and, "MAC_AND", &kp A &kp N &kp D)
    DEF_MACRO (to,  "MAC_TO",  &kp T &kp O)
    DEF_MACRO (that,"MAC_THAT",&kp T &kp H &kp A &kp T)
    DEF_MACRO (for, "MAC_FOR", &kp F &kp O &kp R)
    DEF_MACRO (was, "MAC_WAS", &kp W &kp A &kp S)
    DEF_MACRO (with,"MAC_WITH",&kp W &kp I &kp T &kp H)
    DEF_MACRO (on,  "MAC_ON",  &kp O &kp N)
    DEF_MACRO (not, "MAC_NOT", &kp N &kp O &kp T)

    DEF_MACRO (der, "MAC_DER",  &kp D &kp E &kp R)
    DEF_MACRO (die, "MAC_DIE",  &kp D &kp I &kp E)
    DEF_MACRO (und, "MAC_UND",  &kp U &kp N &kp D)
    DEF_MACRO (in,  "MAC_IN",   &kp I &kp N)
    DEF_MACRO (den, "MAC_DEN",  &kp D &kp E &kp N)
    DEF_MACRO (von, "MAC_VON",  &kp V &kp O &kp N)
    DEF_MACRO (zu,  "MAC_ZU",   &kp Z &kp U)
    DEF_MACRO (das, "MAC_DAS",  &kp D &kp A &kp S)
    DEF_MACRO (mit, "MAC_MIT",  &kp M &kp I &kp T)
    DEF_MACRO (sich,"MAC_SICH", &kp S &kp I &kp C &kp H)

    mac_kl: macro_kill_line {
      label = "MACRO_KILL_LINE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      wait-ms = <150>;
      bindings = <&macro_press &kp LCTL>, <&macro_tap &kp K>, <&macro_release &kp LCTL>;
    };
    mac_kwl: macro_kill_whole_line {
      label = "MACRO_KILL_WHOLE_LINE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      wait-ms = <150>;
      bindings = <&macro_press &kp LCTRL &kp LSHFT>, <&macro_tap &kp BSPC>, <&macro_release &kp LCTRL &kp LSHFT>;
    };
  };
};

// Combos

/ {
  combos {
    compatible = "zmk,combos";

    // The 10 most frequent English words

    DEF_COMBO (the ,&mac_the ,13 19,L_DEF L_SHF) // T+H = the
    DEF_COMBO (of  ,&mac_of  , 3 33,L_DEF L_SHF) // O+F = of
    DEF_COMBO (and ,&mac_and ,14 20,L_DEF L_SHF) // A+N = and
    DEF_COMBO (to  ,&mac_to  , 3 19,L_DEF L_SHF) // T+O = to
    DEF_COMBO (that,&mac_that,14 19,L_DEF L_SHF) // T+A = that
    DEF_COMBO (for ,&mac_for ,22 33,L_DEF L_SHF) // F+R = for
    DEF_COMBO (was ,&mac_was , 6 14,L_DEF L_SHF) // W+A = was
    DEF_COMBO (with,&mac_with, 6 16,L_DEF L_SHF) // W+I = with
    DEF_COMBO (on  ,&mac_on  , 3 20,L_DEF L_SHF) // O+N = on
    DEF_COMBO (not ,&mac_not ,19 20,L_DEF L_SHF) // N+T = not

    // The 10 most frequent German words

    DEF_COMBO (der, &mac_der, 15 18,L_DEF L_SHF) // D+E = der
    DEF_COMBO (die, &mac_die, 16 18,L_DEF L_SHF) // D+I = die
    DEF_COMBO (und, &mac_und, 17 20,L_DEF L_SHF) // U+N = und
    DEF_COMBO (in,  &mac_in,  16 20,L_DEF L_SHF) // I+N = in
    DEF_COMBO (den, &mac_den, 18 20,L_DEF L_SHF) // D+N = den
    DEF_COMBO (von, &mac_von,  3  9,L_DEF L_SHF) // V+O = von
    DEF_COMBO (zu,  &mac_zu,   2 17,L_DEF L_SHF) // Z+U = zu
    DEF_COMBO (das, &mac_das, 14 18,L_DEF L_SHF) // D+A = das
    DEF_COMBO (mit, &mac_mit, 16  8,L_DEF L_SHF) // M+I = mit
    DEF_COMBO (sich,&mac_sich,16 21,L_DEF L_SHF) // S+I = sich

    // Combos for deletion

    DEF_COMBO (kl,  &mac_kl,  39 44,0) // Tab+Del = kill-line
    DEF_COMBO (kwl, &mac_kwl, 37 44,0) // Esc+Del = kill-whole-line
  };
};

/ {
  keymap {
    compatible = "zmk,keymap";

// The numbers are the position codes of the Yackboard v1:
//
// +-------+-------+-------+-------+-------+-------+       +-------+-------+-------+-------+-------+-------+
// |    0  |    1  |    2  |    3  |    4  |    5  |       |    6  |       |       |       |       |   11  |
// +-------+-------+-------+-------+-------+-------+       +-------+-------+-------+-------+-------+-------+
// |   12  |       |       |       |       |   17  |       |   18  |       |       |       |       |   23  |
// +-------+-------+-------+-------+-------+-------+       +-------+-------+-------+-------+-------+-------+
// |   24  |       |       |       |       |   29  |       |   30  |       |       |       |       |   35  |
// +-------+-------+-------+-------+-------+-------+       +-------+-------+-------+-------+-------+-------+
//         |   36  |       |       |       |   40  |       |   41  |       |       |       |   45  |
//         +-------+-------+-------+-------+-------+       +-------+-------+-------+-------+-------+

    default_layer { // #define L_DEF 0
      bindings = <
    &none             &none            &kp Z         &ad_o               &kp P           &kp Y          &kp W            &kp C           &ad_m          &kp V         &none          &none
    &lyhtq L_FUN Q    &lyhth L_NAV H   &mohta LALT A &mohtl LCTRL E      &lyhtl L_NUM I  &mohtu LWIN U  &mohtr LWIN D    &lyhtr L_NUM T  &mohtn LCTRL N &mohtr LALT S &lyhtr L_NAV R &lyhtss L_FUN S
    &ltt L_DEF L_NUM  &ad_j            &kp RA(P)     &kp RA(Q)           &lyhtl L_DEAD K &ad_ue         &kp B            &lyhtg L_DEAD G &kp L          &kp F         &ad_x          &ltt L_DEF L_NUM
                      &none            &kp ESC       &hold_shift LSHFT A &ht LS(TAB) TAB &none          &none            &kp RET         &kp SPACE      &shbs         &none
        >;
    };

    navigation_layer { // #define L_NAV 1
      bindings = <
    &none             &none            &nd_grave    &ht_ang A LS(COMMA) &kp LS(DOT)     &kp EXCL       &mkp LCLK        &kp HOME       &kp UP        &kp PG_UP    &none          &none
    &nd_caret         &nd_dqt          &nd_apos     &kp COMMA           &kp DOT         &kp QMARK      &mkp MCLK        &kp LEFT       &kp SLCK      &kp RIGHT    &kp LC(HOME)   &kp INS
    &ltt L_DEF L_FUN  &kp RA(LS(SEMI)) &kp RA(N9)   &kp SEMI            &kp COLON       &kp UNDER      &mkp RCLK        &kp END        &kp DOWN      &kp PG_DN    &kp LC(END)    &ltt L_DEF L_FUN
                      &trans           &trans       &trans              &trans          &trans         &trans           &trans         &trans        &trans       &none
      >;
    };

    numbers_layer { // #define L_NUM 2
      bindings = <
    &none             &none            &kp RA(N5)   &ht_brc A LBRC      &kp RBRC        &kp PIPE       &ht_apos A MINUS &kp N7         &kp N8        &kp N9       &none         &none
    &nd_tilde         &ht_bkt A LBKT   &kp RBKT     &ht_par A LPAR      &kp RPAR        &kp BSLH       &kp PLUS         &kp N4         &kp N5        &kp N6       &ht COMMA DOT &kp EQUAL
    &ltt L_DEF L_NAV  &kp AT           &kp HASH     &kp DLLR            &kp PRCNT       &kp AMPS       &ht_caret A STAR &kp N1         &kp N2        &kp N3       &kp SLASH     &ltt L_DEF L_NAV
                      &trans           &trans       &trans              &trans          &trans         &trans           &trans         &kp N0        &trans       &none
      >;
    };

    functions_layer { // #define L_FUN 3
      bindings = <
    &none             &none            &none        &none               &none           &kp C_BRI_UP   &kp K_VOL_UP     &kp F7         &kp F8        &kp F9       &none         &none
    &none             &none            &none        &none               &none           &kp C_BRI_AUTO &kp K_MUTE       &kp F4         &kp F5        &kp F6       &kp F11       &kp F10
    &ltt L_DEF L_BLE  &none            &none        &none               &none           &kp C_BRI_DN   &kp K_VOL_DN     &kp F1         &kp F2        &kp F3       &kp F12       &ltt L_DEF L_BLE
                      &trans           &trans       &trans              &trans          &trans         &trans           &trans         &kp SPACE     &trans       &trans
      >;
    };

    secret_layer { // #define L_BLE 4
      bindings = <
    &none             &none            &none        &none               &none           &none          &none            &none          &none         &none        &none         &none
    &none             &none            &none        &none               &none           &none          &bt BT_SEL 1     &bt BT_SEL 2   &bt BT_SEL 3  &bt BT_SEL 4 &bt BT_SEL 5  &none
    &ltt L_DEF L_DEF  &none            &none        &none               &none           &none          &none            &out OUT_USB   &bt BT_CLR    &out OUT_BLE &none         &ltt L_DEF L_DEF
                      &trans           &kp ESC      &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans
      >;
    };

    one_shift_layer { // #define L_SHF 5
      bindings = <
    &trans            &trans           &trans       &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans        &trans
    &trans            &trans           &trans       &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans        &trans
    &trans            &trans           &trans       &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans        &trans
                      &trans           &trans       &mycaps             &trans          &trans         &trans           &trans         &trans        &trans       &trans
      >;
    };

    dead_key_layer { // #define L_DEAD 6
      bindings = <
    &trans            &trans           &kp GRAVE    &kp RA(LBKT)        &kp RA(RBKT)    &kp RA(N1)     &trans           &trans         &trans        &trans       &trans        &trans
    &kp CARET         &kp DQT          &kp APOS     &kp RA(LBRC)        &kp RA(RBRC)    &kp RA(SLASH)  &trans           &trans         &trans        &trans       &trans        &trans
    &trans            &kp D_CIRQ       &kp TILDE    &trans              &trans          &trans         &trans           &trans         &trans        &trans       &kp D_SLASH   &trans
                      &trans           &trans       &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans
      >;
    };
  };
};
